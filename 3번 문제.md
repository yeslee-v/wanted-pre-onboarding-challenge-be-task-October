# 웹 브라우저에 `네이버`를 검색하고 화면에 `네이버` 화면이 출력이 될 때 까지 내부적으로 어떤 동작들이 수행이 되는지 설명해주세요.

## 1. 브라우저는 해당 도메인(www.naver.com )에 캐시가 들어있는지 확인한다.

- 못 찾았다면, `gethostbyname` 함수를 호출하고, `gethostbyname` 함수는 host명이 로컬의 `hosts` 파일에서 참조될 수 있는지 확인한다.
- 캐시와 `hosts` 파일에서 host명을 찾지 못하면 네트워크 스택에 정의된 **DNS 서버에 요청**을 보낸다.
  - DNS 서버가 같은 서브넷에 존재하면, 네트워크 라이브러리는 **DNS 서버**에 대해 `ARP 프로세스`를 거친다.
  - DNS 서버가 다른 서브넷에 존재하면, 네트워크 라이브러리는 **기존 게이트웨이 IP**에 대해 `ARP 프로세스`를 거친다.
    <br>
    </br>

## 2. ARP 브로드캐스트를 보내기 위해 네트워크 스택 라이브러리가 검색할 `목적지 IP의 주소`와 `인터페이스의 MAC 주소`를 찾는다.

> ARP(Address Resolution Protocol)
>
> - 주소 결정 프로토콜. OSI 7 Layer 중 Data Link layer에 위치한다.
> - IP 주소를 기반으로 MAC 주소를 알아내기 위해 사용한다.

- ARP 캐시가 목적지 IP의 ARP 항목을 갖고 있는지 점검한다.

  - 만약 캐시가 있다면, 라이브러리 함수는 `목적지 IP = MAC` 형태로 결과를 반환한다.
  - 만약 캐시가 없다면,

    - 라우트 테이블을 검색하여 목적지 IP 주소가 로컬 라우트 테이블의 서브넷에 존재하는지 확인한다.
      - 존재하면, 라이브러리는 그 서브넷에 속하는 인터페이스를 활용한다.
      - 존재하지 않는다면, 기본 게이트웨이의 서브넷에 속하는 인터페이스를 활용한다.

  - 컴퓨터와 라우터가 직접 연결되어 있으면 라우터는 `ARP Reply`를 회신한다
  - 컴퓨터가 허브에 연결되어 있으면, 허브가 ARP 요청을 모든 포트에 브로드캐스트한다. 라우터가 허브와 동일한 "Wire"에 연결되어 있으면, 허브가 `ARP Reply`를 회신한다.

  - 컴퓨터가 스위치에 연결되어 있다면, 스위치는 자신의 로컬 CAM/MAC 테이블을 확인하여 어떤 포트가 찾고자하는 MAC 주소를 갖고 있는지 확인한다.

    - 스위치에 해당 MAC 주소가 없다면, ARP 요청을 모든 포트에 다시 브로드캐스트 한다.
    - 스위치에 해당 MAC 주소가 있다면, ARP 요청을 해당 주소의 포트에 보낸다.

  - 라우터가 스위치와 동일한 "Wire"에 있다면, 스위치가 `ARP Reply`를 회신한다.

<br>
</br>

## 3. 브라우저가 목적지 서버의 IP 주소를 받으면, IP 주소에서 host 명과 port 번호를 뽑아낸다.

> HTTP 프로토콜 기본 port 번호: 80
> 
> HTTPS 프로토콜 기본 port 번호: 443

<br>
</br>

## 4. 시스템 라이브러리 `socket`을 호출하고, TCP 소켓 스트림(`AF_INET/AF_INET6`, `SOCK_STREAM`)을 요청한다.

- 이 요청은 TCP 세그먼트가 제작되는 Transport 레이어로 전달된다.
- 목적지 port는 헤더에 더해지고, 출발지 port는 커널의 동적 port 범위에서 선택된다.
- 이 세그먼트는 추가적인 IP 헤더를 덧씌우는 Network 레이어로 보내진다. 목적지 서버의 IP 주소도 담아 패킷을 만든다.
- 패킷이 Link 레이어에 도착하면, 머신 NIC의 MAC 주소에 게이트웨이(로컬 라우터)의 MAC 주소까지 포함한 프레임 헤더가 더해진다.

- 패킷은 `이더넷`, `와이파이`, `무선 통신 네트워크` 중 하나로 전송된다.

  - 대부분의 집이나 소규모 업체의 인터넷 연결은 패킷은 컴퓨터로부터(로컬 네트워크를 통해) 모뎀(MOdulator/DEModulator)으로 보낸다.
    - 디지털 신호(0, 1)이 아날로그 신호(전화, 케이블, 무선 통신 연결등으로 전달되기 적합)로 변환된다.
  - 대부분의 큰 사업체나 몇몇 신축 단지는 데이터를 다음 네트워크까지 디지털로 직접 연결해주는 광케이블 및 다이렉트 이더넷 연결이 존재하기도 한다.

- 패킷은 로컬 서브넷을 관리하는 라우터에 도착하면 자율 시스템(AS)의 보더 라우터 - 다른 자율 시스템 - 목적지 서버에 도달하게 된다.
  - 지나치는 각각의 라우터는 IP헤더로부터 목적지 주소를 추출해서 다음 단계까지 이어준다.
  - IP 헤더 내의 Time to live(TTL) 영역은 라우터가 하나씩 지날 때마다 감소된다.
  - TTL 영역이 0이 되거나 도달한 라우터의 큐에 자리가 없을 때(네트워크 혼잡 등) 패킷은 드랍된다.

<br>
</br>

## 5. 클라이언트 컴퓨터가 자신의 Transport Layer Security(TLS) 버전, 암호 알고리즘 목록 및 사용 가능한 압축 방식을 `ClientHello` 메시지에 담아 서버로 보낸다.

- 서버는 다음 목록을 `ServerHello` 메시지에 담아 답장한다.

  - TLS 버전
  - 선택한 암호 알고리즘 및 압출 방식
  - CA(Certificate Authority)가 사인한 서버의 공개 인증서

    - 대칭키가 생성되기 전까지 클라이언트가 나머지 handshake 과정을 암호화하는데 사용할 공개키를 담고 있다

- 클라이언트는 신뢰할 수 있는 CA 목록을 통해 서버측 디지털 인증서가 유효한지 확인한다

  - 만약 CA를 통해 신뢰성이 확보된다면, 클라이언트는 의사 난수(pseudo-random) 바이트를 생성하여 서버의 공개키로 암호화한다.
    - 난수 바이트는 대칭키를 정하는데 사용된다.
  - 서버는 난수 바이트를 자신의 개인키로 복호화해 대칭 마스터키 생성에 활용한다.
  - 클라이언트는 `Finished` 메시지를 서버에 보내면서, 지금까지의 교환 내역을 해싱한 값을 대칭키로 암호화하여 담는다.
  - 서버는 스스로 해시를 생성해 클라이언트에 도착한 값과 일치하는지 확인한다. 만약 일치하면, 서버도 마찬가지로 대칭키를 통해 암호화한 `Finished` 메시지를 클라이언트에 보낸다.
  - TLS 세션이 대칭키로 암호화된 어플리케이션 (HTTP) 데이터를 전송한다.

<br>
</br>

## 6. 클라이언트가 HTTP만 쓴다면 서버에 다음과 같이 요청을 보낸다.

```
GET / HTTP/1.1
Host: naver.com
Connection: close
[other headers]
```

- HTTP/1.1 : 송신자측에서 응답을 받은 직후에 연결이 끊어질 것이라는 신호를 보내기 위해 "close"라는 연결 옵션을 정의한다
- 영구 접속을 허용하지 않는 HTTP/1.1 어플리케이션은 반드시 "close" 연결 옵션을 모든 메시지에 포함해야 한다.
- 요청과 헤더를 보낸 후, 웹 브라우저는 하나의 빈 줄을 서버에 보내 요청 내용이 모두 보내졌다는 것을 알린다.
- 서버는 요청의 상태를 나타내는 코드와 다음과 같이 답신으로 응답한다.

  ```
  200 OK
  [response headers]
  ```

<br>
</br>

## 7. HTTP 서버에서 요청을 처리한다.

- HTTPD(HTTP 데몬) 서버는 서버측에서 요청을 받는다.
- 서버는 요청을 다음과 같은 파라미터로 쪼갠다.

  - HTTP 요청 메소드: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`
  - 도메인: `naver.com`
  - 요청된 경로/페이지: `/`

- 서버는 다음 세가지 조건을 확인한다.

  - `naver.com`에 해당하는 가상 호스트가 서버에 설정되어 있는지?
  - `naver.com`이 GET 요청을 받을 수 있는지?
  - 해당 클라이언트에게 해당 메소드가 허용되는지?

- 서버는 요청에 대응되는 내용을 가져오는데, 현재 `/`가 메인 파일이기 때문에 인덱스 파일로 가게 된다.
- 서버는 핸들러를 통해 가져온 파일을 분석하는데, `naver`가 JAVA 위에서 동작한다면, 서버는 JAVA를 사용하여 인덱스 파일을 해석, 결과물을 클라이언트로 보낸다.

<br></br>

## 8. 서버가 브라우저에 지원(HTML, CSS, JS, 이미지 등)을 제공하면 브라우저는 다음 프로세스를 수행한다.

- 파싱: HTML, CSS, JS
- 랜더링: DOM 트리 생성 → 트리 랜더링 → 랜더링된 트리 배치 → 랜더링된 트리 색칠

<br></br>

### reference

- [What happens when...](https://github.com/alex/what-happens-when)
